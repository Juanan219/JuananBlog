---
author:
  name: "Juan Antonio Reifs"
date: 2021-06-09
linktitle: Intercionexion de BBDD
type:
- post
- posts
title: Interconexion de servidores de Bases de Datos
weight: 10
series:
- Hugo 101
images:
tags:
  - Bases de datos
  - Oracle
  - Postgres
  - SQL
  - Debian
  - CentOs 8
  - 19c
---

En esta práctica vamos a interconectar diferentes servidores de bases de datos entre sí. Esto sirve para poder acceder a datos que no están almacenados en nuestra base de datos local, puediendo así combinarlos con los datos que ya poseemos.

Vamos a realizar los siguientes puntos:

* **Enlace entre dos servidores ORACLE**

* **Enlace entre dos servidores Postgres**

* **Enlace entre Oracle y Postgres empleando Heterogeneus Services**

Todos los gestores de bases de datos que vamos a interconectar van a estar instalados en diferentes máquinas.

## Interconexión de ORACLE a ORACLE

Para la interconexión de los servidores ORACLE vamos a usar las mismas dos máquinas que usamos en el post de [Instalación y configuración de Oracle 19c en CentOs 8](https://juanan219.github.io/posts/2021/06/instalacion-y-configuracion-de-oracle-19c-en-centos-8/). Estas máquinas tienen los listener bien configurados, junto con sus hostnames y FQDN así que partiendo de ese punto vamos a comenzar con la configuración de la interconexión de estos dos servidores.

Esta conexión es unidireccional, lo que quiere decir que la tendremos que hacer tanto en la máquina `oracle1` como en `oracle2`, así que comenzaremos por `oracle1`

### Configuración de oracle1

Vamos a comprobar si tenemos conexión con el listener de `oracle2`, para ello ejecutaremos el comando `tnsping`
~~~
[oracle@oracle1 ~]$ tnsping oracle1

TNS Ping Utility for Linux: Version 19.0.0.0.0 - Production on 07-JUN-2021 13:53:12

Copyright (c) 1997, 2019, Oracle.  All rights reserved.

Used parameter files:
/opt/oracle/product/19c/dbhome_1/network/admin/sqlnet.ora

Used HOSTNAME adapter to resolve the alias
Attempting to contact (DESCRIPTION=(CONNECT_DATA=(SERVICE_NAME=))(ADDRESS=(PROTOCOL=tcp)(HOST=192.168.1.49)(PORT=1521)))
OK (0 msec)
~~~

Como podemos comprobar, en la última línea de la salida del anterior comando nos ha dado como resultado `OK (0 msec)`, con lo que podemos deducir que los servidores tienen conexión entre ellos (al menos `oracle1` con `oracle2`). Sabiendo esto, el siguiente paso será modificar el fichero `tnsnames.ora`, el cual se encuentra en la misma ubicación que el `listener.ora`, es decir, en `$ORACLE_HOME/network/admin/tnsnames.ora`. El contenido predeterminado del fichero es el siguiente
~~~
# tnsnames.ora Network Configuration File: /opt/oracle/product/19c/dbhome_1/network/admin/tnsnames.ora
# Generated by Oracle configuration tools.

ORCLCDB =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = oracle1.juanan.es)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = ORCLCDB)
    )
  )

LISTENER_ORCLCDB =
  (ADDRESS = (PROTOCOL = TCP)(HOST = oracle1.juanan.es)(PORT = 1521))
~~~

A este fichero añadiremos un nuevo alias para la máquina `oracle2` (cuyo nombre puede ser el que nosotros queramos, ya que esto es solo descriptivo para nosotros), por lo que añadiríamos las siguientes líneas:
~~~
ORACLE2 =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = oracle2)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = ORCLCDB)
    )
  )
~~~

Con lo cual, el resultado final del fichero sería el siguiente
~~~
# tnsnames.ora Network Configuration File: /opt/oracle/product/19c/dbhome_1/network/admin/tnsnames.ora
# Generated by Oracle configuration tools.

ORCLCDB =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = oracle1.juanan.es)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = ORCLCDB)
    )
  )

LISTENER_ORCLCDB =
  (ADDRESS = (PROTOCOL = TCP)(HOST = oracle1.juanan.es)(PORT = 1521))

ORACLE2 =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = oracle2)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = ORCLCDB)
    )
  )
~~~

Antes de proseguir con la creación del enlace con `oracle2`, vamos a crear un usuario con una base de datos de ejemplo en la máquina `oracle2`
~~~
# Creamos el usuario de prueba

SQL> create user c##prueba identified by prueba;

Usuario creado.

# Le asignamos todos los privilegios (esto no es seguro hacerlo en un escenario real. Yo lo hago porque es una prueba.)

SQL> grant all privileges to c##prueba;

Concesion terminada correctamente.

# Iniciamos sesión con el usuario que acabamos de crear

[oracle@oracle2 ~]$ sqlplus c##prueba/prueba

# Creamos la tabla EMP del esquema de SCOTT e insertamos sus datos

CREATE TABLE EMP (
        EMPNO NUMBER(4),
        ENAME VARCHAR2(10),
        JOB VARCHAR2(9),
        MGR NUMBER(4),
        HIREDATE DATE,
        SAL NUMBER(7,2),
        COMM NUMBER(7,2),
        DEPTNO NUMBER(2),
        CONSTRAINT PK_EMPNO_DEPTNO PRIMARY KEY (EMPNO, DEPTNO));

INSERT INTO EMP VALUES (7369,'SMITH','CLERK',7902,to_date('17-12-1980','dd-mm-yyyy'),800,NULL,20);
INSERT INTO EMP VALUES (7499,'ALLEN','SALESMAN',7698,to_date('20-2-1981','dd-mm-yyyy'),1600,300,30);
INSERT INTO EMP VALUES (7521,'WARD','SALESMAN',7698,to_date('22-2-1981','dd-mm-yyyy'),1250,500,30);
INSERT INTO EMP VALUES (7566,'JONES','MANAGER',7839,to_date('2-4-1981','dd-mm-yyyy'),2975,NULL,20);
INSERT INTO EMP VALUES (7654,'MARTIN','SALESMAN',7698,to_date('28-9-1981','dd-mm-yyyy'),1250,1400,30);
INSERT INTO EMP VALUES (7698,'BLAKE','MANAGER',7839,to_date('1-5-1981','dd-mm-yyyy'),2850,NULL,30);
INSERT INTO EMP VALUES (7782,'CLARK','MANAGER',7839,to_date('9-6-1981','dd-mm-yyyy'),2450,NULL,10);
INSERT INTO EMP VALUES (7788,'SCOTT','ANALYST',7566,to_date('13-JUL-87')-85,3000,NULL,20);
INSERT INTO EMP VALUES (7839,'KING','PRESIDENT',NULL,to_date('17-11-1981','dd-mm-yyyy'),5000,NULL,10);
INSERT INTO EMP VALUES (7844,'TURNER','SALESMAN',7698,to_date('8-9-1981','dd-mm-yyyy'),1500,0,30);
INSERT INTO EMP VALUES (7876,'ADAMS','CLERK',7788,to_date('13-JUL-87')-51,1100,NULL,20);
INSERT INTO EMP VALUES (7900,'JAMES','CLERK',7698,to_date('3-12-1981','dd-mm-yyyy'),950,NULL,30);
INSERT INTO EMP VALUES (7902,'FORD','ANALYST',7566,to_date('3-12-1981','dd-mm-yyyy'),3000,NULL,20);
INSERT INTO EMP VALUES (7934,'MILLER','CLERK',7782,to_date('23-1-1982','dd-mm-yyyy'),1300,NULL,10);

# Comprobamos que se ha hecho correctamente

SQL> select * from emp;

     EMPNO ENAME      JOB	       MGR HIREDATE	   SAL	     COMM
---------- ---------- --------- ---------- -------- ---------- ----------
    DEPTNO
----------
      7369 SMITH      CLERK	      7902 17/12/80	   800
	20

      7499 ALLEN      SALESMAN	      7698 20/02/81	  1600	      300
	30

      7521 WARD       SALESMAN	      7698 22/02/81	  1250	      500
	30


     EMPNO ENAME      JOB	       MGR HIREDATE	   SAL	     COMM
---------- ---------- --------- ---------- -------- ---------- ----------
    DEPTNO
----------
      7566 JONES      MANAGER	      7839 02/04/81	  2975
	20

      7654 MARTIN     SALESMAN	      7698 28/09/81	  1250	     1400
	30

      7698 BLAKE      MANAGER	      7839 01/05/81	  2850
	30


     EMPNO ENAME      JOB	       MGR HIREDATE	   SAL	     COMM
---------- ---------- --------- ---------- -------- ---------- ----------
    DEPTNO
----------
      7782 CLARK      MANAGER	      7839 09/06/81	  2450
	10

      7788 SCOTT      ANALYST	      7566 19/04/87	  3000
	20

      7839 KING       PRESIDENT 	   17/11/81	  5000
	10


     EMPNO ENAME      JOB	       MGR HIREDATE	   SAL	     COMM
---------- ---------- --------- ---------- -------- ---------- ----------
    DEPTNO
----------
      7844 TURNER     SALESMAN	      7698 08/09/81	  1500		0
	30

      7876 ADAMS      CLERK	      7788 23/05/87	  1100
	20

      7900 JAMES      CLERK	      7698 03/12/81	   950
	30


     EMPNO ENAME      JOB	       MGR HIREDATE	   SAL	     COMM
---------- ---------- --------- ---------- -------- ---------- ----------
    DEPTNO
----------
      7902 FORD       ANALYST	      7566 03/12/81	  3000
	20

      7934 MILLER     CLERK	      7782 23/01/82	  1300
	10


14 filas seleccionadas.
~~~

Para hacer la prueba, vamos a crear una tabla del esquema de SCOTT en el usuario `c##juanan` de la máquina `oracle1`
~~~
# Creamos la tabla DEPT del esquema de SCOTT e insertamos los datos

CREATE TABLE DEPT (
        DEPTNO NUMBER(2) CONSTRAINT PK_DEPT PRIMARY KEY,
        DNAME VARCHAR2(14),
        LOC VARCHAR2(13));

INSERT INTO DEPT VALUES (10,'ACCOUNTING','NEW YORK');
INSERT INTO DEPT VALUES (20,'RESEARCH','DALLAS');
INSERT INTO DEPT VALUES (30,'SALES','CHICAGO');
INSERT INTO DEPT VALUES (40,'OPERATIONS','BOSTON');

# Comprobamos que se ha hecho correctamente

SQL> select * from dept;

    DEPTNO DNAME	  LOC
---------- -------------- -------------
	10 ACCOUNTING	  NEW YORK
	20 RESEARCH	  DALLAS
	30 SALES	  CHICAGO
	40 OPERATIONS	  BOSTON
~~~

Ahora pasamos a crear el enlace con `oracle2`
~~~
# Iniciamos sesión con nuestro usuario en oracle1

[oracle@oracle1 ~]$ sqlplus c##juanan/juanan

# Creamos el enlace con la siguiente instrucción

SQL> create database link oracle2link
connect to c##prueba identified by prueba
using 'ORACLE2';

Enlace con la base de datos creado.
~~~

Se acaba de crear el enlace con la máquina `oracle2`, así que vamos a realizar una consulta en la que se muestre el nombre del empleado junto con el nombre del departamento al que pertenece, ya que cada una de las tablas están en diferentes máquinas y, por lo cual, están en diferentes bases de datos:
~~~
SQL> select emp.ename, dept.dname
from emp@oracle2link emp, dept
where emp.deptno = dept.deptno;

ENAME	   DNAME
---------- --------------
CLARK	   ACCOUNTING
KING	   ACCOUNTING
MILLER	   ACCOUNTING
SMITH	   RESEARCH
JONES	   RESEARCH
SCOTT	   RESEARCH
ADAMS	   RESEARCH
FORD	   RESEARCH
ALLEN	   SALES
WARD	   SALES
MARTIN	   SALES

ENAME	   DNAME
---------- --------------
BLAKE	   SALES
TURNER	   SALES
JAMES	   SALES

14 filas seleccionadas.
~~~

### Configuración de oracle2

Básicamente vamos a realizar las mismas modificaciones que en la máquina `oracle1`, pero esta vez en la máquina `oracle2`, así que para no extender mucho más el post, voy a realizarlo todo sin más explicaciones que las que hay ya escritas arriba:
~~~
# Comprobamos que tenemos ping con tnsping

[oracle@oracle2 ~]$ tnsping oracle1

TNS Ping Utility for Linux: Version 19.0.0.0.0 - Production on 08-JUN-2021 02:47:16

Copyright (c) 1997, 2019, Oracle.  All rights reserved.

Used parameter files:
/opt/oracle/product/19c/dbhome_1/network/admin/sqlnet.ora


Used TNSNAMES adapter to resolve the alias
Attempting to contact (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.49)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = ORCLCDB)))
OK (0 msec)

# Modificamos el tnsnames.ora

[oracle@oracle2 ~]$ sudo nano $ORACLE_HOME/network/admin/tnsnames.ora

# tnsnames.ora Network Configuration File: /opt/oracle/product/19c/dbhome_1/network/admin/tnsnames.ora
# Generated by Oracle configuration tools.

ORCLCDB =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.29)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = ORCLCDB)
    )
  )

LISTENER_ORCLCDB =
  (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.29)(PORT = 1521))

ORACLE1 =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.49)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = ORCLCDB)
    )
  )

# Iniciamos sesión con el usuario prueba y conectamos las bases de datos

[oracle@oracle2 ~]$ sqlplus c##prueba/prueba

SQL> create database link oracle1link
connect to c##juanan identified by juanan
using 'ORACLE1';

Enlace con la base de datos creado.

# Realizamos la misma consulta que antes, pero esta vez a la inversa

SQL> select emp.ename, dept.dname
from emp, dept@oracle1link dept
where emp.deptno = dept.deptno;

ENAME	   DNAME
---------- --------------
CLARK	   ACCOUNTING
KING	   ACCOUNTING
MILLER	   ACCOUNTING
SMITH	   RESEARCH
JONES	   RESEARCH
SCOTT	   RESEARCH
ADAMS	   RESEARCH
FORD	   RESEARCH
ALLEN	   SALES
WARD	   SALES
MARTIN	   SALES

ENAME	   DNAME
---------- --------------
BLAKE	   SALES
TURNER	   SALES
JAMES	   SALES

14 filas seleccionadas.
~~~

## Interconexión de Postres a Postgres

Ahora es el turno de configurar dos servidores PostgreSQL de la misma manera que hemos hecho con los servidores ORACLE para así poder combinar nuestros datos de dos bases de datos diferentes alojadas en máquinas diferentes, para ello vamos a partir del punto de tener dos máquinas debian10 limpies y recién instaladas, por lo cual no tienen ningún tipo de configuración hecha.

### Configuración de hostname y FQDN

Para diferencias las máquinas vamos a ponerles nombres dentro de mi dominio ficticio, por lo cual, la máquina 1 se va a llamar phoenix y la máquina 2 se llamará killjoy. Así que lo primero que tendremos que hacer será configurar nuestro hostname, para ello primero editaremos el fichero `/etc/hostname` de la máquina 1
~~~
usuario@debian:~$ sudo nano /etc/hostname

phoenix
~~~

Y editamos el fichero `/etc/hosts` para establecer correctamente nuestro FQDN de phoenix
~~~
usuario@debian:~$ sudo nano /etc/hosts
[...]
127.0.1.1       phoenix.juanan.es       phoenix
[...]
~~~

Comprobamos que todo está correcto
~~~
usuario@phoenix:~$ hostname
phoenix
usuario@phoenix:~$ hostname -f
phoenix.juanan.es
~~~

Ahora pasamos a la configuración de lo mismo pero de la máquina 2
~~~
# Modificamos el fichero /etc/hostname

usuario@debian:~$ sudo nano /etc/hostname

killjoy

# Modificamos el fichero /etc/hosts

usuario@debian:~$ sudo nano /etc/hosts
[...]
127.0.1.1       killjoy.juanan.es       killjoy
[...]

# Comprobamos que todo está correcto

usuario@killjoy:~$ hostname
killjoy
usuario@killjoy:~$ hostname -f
killjoy.juanan.es
~~~

### Configuración de postgres en Phoenix

Una vez que tenemos nuestros hostnames y FQDNs bien configurados, es hora de pasar a la configuración de nuestras bases de datos, para ello vamos a instalar el gestor de bases de datos postgres en nuestra máquina Phoenix
~~~
usuario@phoenix:~$ sudo apt-get update && sudo apt-get install -y postgresql
~~~

Cuando se haya instalado, podemos comprobar que se ha iniciado automáticamente el proceso del gestor de bases de datos
~~~
usuario@phoenix:~$ sudo systemctl status postgresql
● postgresql.service - PostgreSQL RDBMS
   Loaded: loaded (/lib/systemd/system/postgresql.service; enabled; vendor preset: enabled)
   Active: active (exited) since Tue 2021-06-08 09:24:54 CEST; 1min 4s ago
 Main PID: 2255 (code=exited, status=0/SUCCESS)
    Tasks: 0 (limit: 2359)
   Memory: 0B
   CGroup: /system.slice/postgresql.service

jun 08 09:24:54 phoenix systemd[1]: Starting PostgreSQL RDBMS...
jun 08 09:24:54 phoenix systemd[1]: Started PostgreSQL RDBMS.
~~~

Por lo tanto debe haber abierto el puerto predeterminado (5432) para realizar conexiones en red. Para comprobar esto, instalaremos el paquete `net-tools` para poder ejecutar el comando `netstat`
~~~
usuario@phoenix:~$ sudo apt-get install net-tools

usuario@phoenix:~$ netstat -tln
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State          
[...]
tcp        0      0 127.0.0.1:5432          0.0.0.0:*               LISTEN     
[...]    
tcp6       0      0 ::1:5432                :::*                    LISTEN
~~~

Cuando tengamos todo listo, vamos a iniciar sesión con postgres e iniciamos una shell de `psql`
~~~
root@phoenix:~# su - postgres
postgres@phoenix:~$ psql
psql (11.12 (Debian 11.12-0+deb10u1))
Digite «help» para obtener ayuda.

postgres=#
~~~

Para tener algo con lo que trabajar posteriormente vamos a crear una base de datos y un rol que sea el administrador de la misma (los usuarios en postgres se llaman roles) y vamos a introducir de nuevo la información del esquema de SCOTT pero ahora pasado al formato de postgres
~~~
# Creamos la base de datos

postgres=# create database esquema_scott_1;
CREATE DATABASE

# Comprobamos que se ha creado la base de datos

postgres=# \l
                                   Listado de base de datos
     Nombre      |  Dueño   | Codificación |   Collate   |    Ctype    |      Privilegios      
-----------------+----------+--------------+-------------+-------------+-----------------------
 esquema_scott_1 | postgres | UTF8         | es_ES.UTF-8 | es_ES.UTF-8 | 
[...]

# Creamos el usuario

postgres=# create user juanan1 with password 'juanan';
CREATE ROLE

# Le asignamos todos los privilegios sobre la base de datos que acabamos de crear

postgres=# grant all privileges on database esquema_scott_1 to juanan1;
GRANT

# Iniciamos sesión con el rol creado

postgres@phoenix:~$ psql -h localhost -U juanan1 -d esquema_scott_1
Contraseña para usuario juanan1: 
psql (11.12 (Debian 11.12-0+deb10u1))
conexión SSL (protocolo: TLSv1.3, cifrado: TLS_AES_256_GCM_SHA384, bits: 256, compresión: desactivado)
Digite «help» para obtener ayuda.

esquema_scott_1=>

# Creamos la tabla DEPT e insertamos sus datos

CREATE TABLE DEPT
(DEPTNO NUMERIC(2),
 DNAME VARCHAR(14),
 LOC VARCHAR(13),
 CONSTRAINT PK_DEPTNO PRIMARY KEY (DEPTNO));

INSERT INTO DEPT VALUES (10,'ACCOUNTING','NEW YORK');
INSERT INTO DEPT VALUES (20,'RESEARCH','DALLAS');
INSERT INTO DEPT VALUES (30,'SALES','CHICAGO');
INSERT INTO DEPT VALUES (40,'OPERATIONS','BOSTON');

# Comprobamos que se han realizado correctamente

esquema_scott_1=> \d
       Listado de relaciones
 Esquema | Nombre | Tipo  |  Dueño  
---------+--------+-------+---------
 public  | dept   | tabla | juanan1
(1 fila)

esquema_scott_1=> select * from dept;
 deptno |   dname    |   loc    
--------+------------+----------
     10 | ACCOUNTING | NEW YORK
     20 | RESEARCH   | DALLAS
     30 | SALES      | CHICAGO
     40 | OPERATIONS | BOSTON
(4 filas)
~~~

Ahora que tenemos parte del esquema en nuestra base de datos, vamos a comenzar con la configuración para poder usar dicha base de datos de forma remota.
Como hemos visto con el comando `netstat` postgres solo está escuchando en la dirección de `localhost`, por lo cual eso lo deberemos cambiar y configurar para que escuche en la tarjeta de red de nuestra máquina que acceda a internet, en mi caso es mi única tarjeta de red. Para saber la ip ejecutaremos el comando `ip a` y después modificaremos ciertos parámetros del fichero `/etc/postgresql/11/main/postgresql.conf`, los cuales indicaré ahora mismo
~~~
# Comprobamos nuestra dirección ip

usuario@phoenix:~$ ip a
[...]
inet 192.168.1.138/24 brd 192.168.1.255 scope global dynamic enp0s3
[...]

# Descomentamos la línea 59 del fichero /etc/postgresql/11/main/postgresql.conf y cambiamos localhost por nuestra ip

usuario@phoenix:~$ sudo nano /etc/postgresql/11/main/postgresql.conf
[...]
listen_addresses = '*'			# what IP address(es) to listen on;
[...]
~~~

Guardamos las modificaciones y pasamos a modificar un segundo fichero de configuración, el cual se encuentra en `/etc/postgresql/11/main/pg_hba.conf`, en el cual indicaremos quién puede usar nuestro clúster de bases de datos
~~~
# Modificamos la línea 92 y cambiamos la dirección ip de localhost (127.0.0.1/32) por all
usuario@phoenix:~$ sudo nano /etc/postgresql/11/main/pg_hba.conf
[...]
# IPv4 local connections:
host    all             all             all                     md5
[...]

# Guardamos y reiniciamos el servicio

usuario@phoenix:~$ sudo systemctl restart postgresql
~~~

Cuando hayamos terminado de configurar estos dos fichero y reiniciado el servicio para aplicar los cambios, vamos a comprobar con el mismo comando de antes (`netstat`) que se han aplicado los cambios correctamente y que está escuchando por donde debería
~~~
usuario@killjoy:~$ netstat -tln
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
[...]
tcp        0      0 0.0.0.0:5432            0.0.0.0:*               LISTEN     
[...]
tcp6       0      0 :::5432                 :::*                    LISTEN
~~~

### Configuración de Killjoy

Haremos la misma configuración que en la máquina anterior y crearemos el rol `juanan2` e insertaremos la tabla `emp` del esquema de `SCOTT`.
~~~
# Instalamos postgres y net-tools

usuario@killjoy:~$ sudo apt-get update && sudo apt-get install -y postgresql net-tools

# Iniciamos sesión con el usuario postgres y accedemos a la shell de postgres

root@killjoy:~# cerrar sesión
usuario@killjoy:~$ sudo su -
root@killjoy:~# su - postgres
postgres@killjoy:~$ psql
psql (11.12 (Debian 11.12-0+deb10u1))
Digite «help» para obtener ayuda.

postgres=#

# Creamos la base de datos junto con su rol y le asignamos los permisos

postgres=# create database esquema_scott_2;
CREATE DATABASE

postgres=# create user juanan2 with password 'juanan';
CREATE ROLE

postgres=# grant all privileges on database esquema_scott_2 to juanan2;
GRANT

# Iniciamos sesión como juanan2 y creamos la tabla emp de SCOTT junto con sus datos

postgres@killjoy:~$ psql -h localhost -U juanan2 -d esquema_scott_2
Contraseña para usuario juanan2: 
psql (11.12 (Debian 11.12-0+deb10u1))
conexión SSL (protocolo: TLSv1.3, cifrado: TLS_AES_256_GCM_SHA384, bits: 256, compresión: desactivado)
Digite «help» para obtener ayuda.

esquema_scott_2=> CREATE TABLE EMP (
EMPNO NUMERIC(4),
ENAME VARCHAR(10),
JOB VARCHAR(9),
MGR NUMERIC(4),
HIREDATE DATE,
SAL NUMERIC(7,2),
COMM NUMERIC(7,2),
DEPTNO NUMERIC(2),
CONSTRAINT PK_EMPNO_DEPTNO PRIMARY KEY (EMPNO, DEPTNO));

INSERT INTO EMP VALUES (7369,'SMITH','CLERK',7902,to_date('17-12-1980','dd-mm-yyyy'),800,NULL,20);
INSERT INTO EMP VALUES (7499,'ALLEN','SALESMAN',7698,to_date('20-2-1981','dd-mm-yyyy'),1600,300,30);
INSERT INTO EMP VALUES (7521,'WARD','SALESMAN',7698,to_date('22-2-1981','dd-mm-yyyy'),1250,500,30);
INSERT INTO EMP VALUES (7566,'JONES','MANAGER',7839,to_date('2-4-1981','dd-mm-yyyy'),2975,NULL,20);
INSERT INTO EMP VALUES (7654,'MARTIN','SALESMAN',7698,to_date('28-9-1981','dd-mm-yyyy'),1250,1400,30);
INSERT INTO EMP VALUES (7698,'BLAKE','MANAGER',7839,to_date('1-5-1981','dd-mm-yyyy'),2850,NULL,30);
INSERT INTO EMP VALUES (7782,'CLARK','MANAGER',7839,to_date('9-6-1981','dd-mm-yyyy'),2450,NULL,10);
INSERT INTO EMP VALUES (7839,'KING','PRESIDENT',NULL,to_date('17-11-1981','dd-mm-yyyy'),5000,NULL,10);
INSERT INTO EMP VALUES (7844,'TURNER','SALESMAN',7698,to_date('8-9-1981','dd-mm-yyyy'),1500,0,30);
INSERT INTO EMP VALUES (7900,'JAMES','CLERK',7698,to_date('3-12-1981','dd-mm-yyyy'),950,NULL,30);
INSERT INTO EMP VALUES (7902,'FORD','ANALYST',7566,to_date('3-12-1981','dd-mm-yyyy'),3000,NULL,20);
INSERT INTO EMP VALUES (7934,'MILLER','CLERK',7782,to_date('23-1-1982','dd-mm-yyyy'),1300,NULL,10);
INSERT INTO EMP VALUES (7788,'SCOTT','ANALYST',7566,to_date('13-7-87', 'dd-mm-yyyy')-85,3000,NULL,20);
INSERT INTO EMP VALUES (7876,'ADAMS','CLERK',7788,to_date('13-7-87', 'dd-mm-yyyy')-51,1100,NULL,20);

# Comprobación de que todo está correcto

esquema_scott_2=> select * from emp;
 empno | ename  |    job    | mgr  |  hiredate  |   sal   |  comm   | deptno 
-------+--------+-----------+------+------------+---------+---------+--------
  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |         |     20
  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30
  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30
  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |         |     20
  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30
  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |         |     30
  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |         |     10
  7839 | KING   | PRESIDENT |      | 1981-11-17 | 5000.00 |         |     10
  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30
  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |         |     30
  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |         |     20
  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |         |     10
  7788 | SCOTT  | ANALYST   | 7566 | 0087-04-19 | 3000.00 |         |     20
  7876 | ADAMS  | CLERK     | 7788 | 0087-05-23 | 1100.00 |         |     20
(14 filas)

# Modificamos el fichero /etc/postgresql/11/main/postgresql.conf

usuario@killjoy:~$ sudo nano /etc/postgresql/11/main/postgresql.conf

[...]
listen_addresses = '*'                  # what IP address(es) to listen on;
[...]

# Modificamos el fichero /etc/postgresql/11/main/pg_hba.conf

usuario@killjoy:~$ sudo nano /etc/postgresql/11/main/pg_hba.conf

[...]
# IPv4 local connections:
host    all             all             all                     md5
[...]

# Reiniciamos el servicio de postgresql

usuario@killjoy:~$ sudo systemctl restart postgresql
~~~

### Creación de los enlaces

Ahora pasaremos a crear los enlaces entre las dos máquinas, para ello deberemos instalar el paquete `postgresql-contrib` y creamos el enlace desde la base de datos que hemos creado anteriormente, es decir, `esquema_scott_1`
~~~
usuario@phoenix:~$ sudo apt-get install -y postgresql-contrib

root@phoenix:~# su - postgres

postgres@phoenix:~$ psql -d esquema_scott_1
psql (11.12 (Debian 11.12-0+deb10u1))
Digite «help» para obtener ayuda.

esquema_scott_1=# create extension dblink;
CREATE EXTENSION
~~~

Cuando hayamos creado el `dblink` salimos del usuario root de `psql` e iniciamos sesión con el usuario `juanan1` para poder hacer la consulta. En este caso, la consulta nos deberá mostrar el `ename` del empleado y el `dname` del departamento al que pertenece
~~~
esquema_scott_1=> select emp.ename, dept.dname
esquema_scott_1-> from dept, dblink('dbname=esquema_scott_2 host=192.168.1.149 user=juanan2 password=juanan', 'select ename, deptno from emp') as emp (ename varchar, deptno numeric)
esquema_scott_1-> where dept.deptno = emp.deptno;
 ename  |   dname    
--------+------------
 SMITH  | RESEARCH
 ALLEN  | SALES
 WARD   | SALES
 JONES  | RESEARCH
 MARTIN | SALES
 BLAKE  | SALES
 CLARK  | ACCOUNTING
 KING   | ACCOUNTING
 TURNER | SALES
 JAMES  | SALES
 FORD   | RESEARCH
 MILLER | ACCOUNTING
 SCOTT  | RESEARCH
 ADAMS  | RESEARCH
(14 filas)
~~~

Si queremos hacer lo mismo pero en la máquina `killjoy`, deberemos realizar los mismos pasos
~~~
# Instalamos el paquete necesario para realizar la conexión

usuario@killjoy:~$ sudo apt-get install -y postgresql-contrib

# Iniciamos sesión como root en la shell de psql e iniciamos el dblink

postgres@killjoy:~$ psql -d esquema_scott_2

esquema_scott_2=# create extension dblink;
CREATE EXTENSION

# Iniciamos sesión como juanan2 y hacemos la consulta

postgres@killjoy:~$ psql -h localhost -U juanan2 -d esquema_scott_2
Contraseña para usuario juanan2: 
psql (11.12 (Debian 11.12-0+deb10u1))
conexión SSL (protocolo: TLSv1.3, cifrado: TLS_AES_256_GCM_SHA384, bits: 256, compresión: desactivado)
Digite «help» para obtener ayuda.

esquema_scott_2=> select emp.ename, dept.dname
esquema_scott_2-> from emp, dblink('dbname=esquema_scott_1 host=192.168.1.20 user=juanan1 password=juanan', 'select deptno,dname from dept') as dept (deptno numeric, dname varchar)
esquema_scott_2-> where emp.deptno = dept.deptno;
 ename  |   dname    
--------+------------
 MILLER | ACCOUNTING
 KING   | ACCOUNTING
 CLARK  | ACCOUNTING
 ADAMS  | RESEARCH
 SCOTT  | RESEARCH
 FORD   | RESEARCH
 JONES  | RESEARCH
 SMITH  | RESEARCH
 JAMES  | SALES
 TURNER | SALES
 BLAKE  | SALES
 MARTIN | SALES
 WARD   | SALES
 ALLEN  | SALES
(14 filas)
~~~

## Interconexión entre Oracle y Postgres usando heterogeneus services

En este caso, vamos a interconectar dos de los servidores de los anteriores puntos, en mi caso, voy a usar a Phoenix (debian 10 con PostgreSQL, el cual contiene la tabla dept del esquema de scott) y a oracle2 (CentOS 8 con Oracle 19c, el cual contiene la tabla emp del esquema de scott). Estos dos servidores ya están configurados para recibir peticiones desde el exterior.

El problema de interconectar un Oracle con un PostgreSQL está en que Oracle tiene un servicio destinado a la conexión de servidores de bases de datos y PostgreSQL no, por lo que en estos casos deberemos usar *ODBC* (Open Database Conectivity).

Para realizar la conexión de Oracle a PostgreSQL mediante *ODBC* tenemos que asegurarnos de que tenemos la paquetería necesaria instalada, en este caso necesitaremos el paquete `unixODBC` y `posgresql-odbc`.
~~~
[oracle@oracle2 ~]$ sudo dnf install -y unixODBC postgresql-odbc
~~~

Cuando se hayan instalado los paquetes, deberemos modificar el fichero `/etc/odbcinst.ini`, ya que es el que tiene las rutas de todas las librerías que se usan para interconectar todos los servicios que esta herramienta es capaz de conectar, pero como a nosotros solo nos interesa PostgreSQL, comentaremos todas las lineas que no tengan que ver con este gestor de bases de datos
~~~
# Solo nos hace falta esta parte

[PostgreSQL]
Description     = ODBC for PostgreSQL
Driver          = /usr/lib/psqlodbcw.so
Setup           = /usr/lib/libodbcpsqlS.so
Driver64        = /usr/lib64/psqlodbcw.so
Setup64         = /usr/lib64/libodbcpsqlS.so
FileUsage	= 1
~~~

Ahora crearemos un *DSN* (Data Source Name) en el fichero `/etc/odbc.ini`, ya que este fichero es el que se va a encargar de indicar la forma en la que nos vamos a conectar al servidor de PostgreSQL.
~~~
# Este fichero, de primeras está vacío, por lo que tendremos que definir los parámetros de conexión con el servidor de PostgeSQL

[PHOENIX]
Debug           = 0
CommLog         = 0
ReadOnly        = 0
Driver          = PostgreSQL
Servername	= 192.168.1.20 
Username        = juanan1
Password        = juanan 
Port            = 5432
Database        = esquema_scott_1
Trace           = 0
TraceFile	= /tmp/sql.log
~~~

Ahora que lo tenemos configurado, vamos a realizar una conexión desde `oracle2` hacia `phoenix` con la herramienta `isql`
~~~
[oracle@oracle2 ~]$ isql PHOENIX
+---------------------------------------+
| Connected!                            |
|                                       |
| sql-statement                         |
| help [tablename]                      |
| quit                                  |
|                                       |
+---------------------------------------+
SQL>
~~~

Como podemos ver hemos realizado una conexión exitosa, por lo que al habernos conectado a la shell de phoenix podemos listar el contenido de sus tablas como se ve a continuación.
~~~
SQL> select * from dept;
+-------+---------------+--------------+
| deptno| dname         | loc          |
+-------+---------------+--------------+
| 10    | ACCOUNTING    | NEW YORK     |
| 20    | RESEARCH      | DALLAS       |
| 30    | SALES         | CHICAGO      |
| 40    | OPERATIONS    | BOSTON       |
+-------+---------------+--------------+
SQLRowCount returns 4
4 rows fetched
~~~

Ya podemos realizar una conexión desde nuestro centos 8 hacia postgresql, pero oracle no tiene la capacidad de usar esos drives todavía, por lo que deberemos crear un archivo de *Heterogeneus Services*, para ello nos dirigiremos a `$ORACLE_HOME/hs/admin` y creamos un fichero llamado `init[DSN].ora`, en mi caso llamado `initPHOENIX.ora` con los siguientes elementos en su interior
~~~
[oracle@oracle2 admin]$ sudo nano $ORACLE_HOME/hs/admin/initPHOENIX.ora

HS_FDS_CONNECT_INFO = PHOENIX
HS_FDS_TRACE_LEVEL = DEBUG
HS_FDS_SHAREABLE_NAME = /usr/lib64/psqlodbcw.so
HS_LANGUAGE = AMERICAN_AMERICA.WE8ISO8859P1
set ODBCINI=/etc/odbc.ini
~~~

El siguiente paso será añadir el driver *ODBC* al listner, para ello lo vamos a añadir al fichero `listener.ora`, de tal manera que quedará de la siguiente forma:
~~~
[oracle@oracle2]$ sudo nano $ORACLE_HOME/network/admin/listener.ora

# listener.ora Network Configuration File: /opt/oracle/product/19c/dbhome_1/network/admin/listener.ora
# Generated by Oracle configuration tools.

LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.29)(PORT = 1521))
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
    )
  )

SID_LIST_LISTENER=
  (SID_LIST=
      (SID_DESC=
         (SID_NAME=PHOENIX)
         (ORACLE_HOME=/opt/oracle/product/19c/dbhome_1)
         (PROGRAM=dg4odbc)
      )
  )
~~~

Ahora toca configurar el fichero `tnsnames.ora`, el cual está ubicado en `$ORACLE_HOME/network/admin`, en el que añadiremos el drive anteriormente mencionado
~~~
PHOENIX  =
  (DESCRIPTION=
    (ADDRESS=(PROTOCOL=tcp)(HOST=localhost)(PORT=1521))
    (CONNECT_DATA=(SID=PHOENIX))
    (HS=OK)
  )
~~~

Una vez que hayamos configurado los ficheros es el turno de iniciar el listener o si ya está iniciado tocará reiniciarlo, para ello usaremos los siguientes comandos:
~~~
# Comando para parar el servicio del listener en el caso de que esté arrancado

[oracle@oracle2 ~]$ lsnrctl stop

# Comando para iniciar el listener

[oracle@oracle2 ~]$ lsnrctl start
~~~

Iniciamos una shell de `sqlplus`, iniciamos la instancia (si no lo está) y creamos un enlace hacia Phoenix
~~~
# Iniciamos como sysdba

[oracle@oracle2 ~]$ sqlplus / as sysdba

SQL*Plus: Release 19.0.0.0.0 - Production on Tue Jun 8 08:56:42 2021
Version 19.3.0.0.0

Copyright (c) 1982, 2019, Oracle.  All rights reserved.

Connected to an idle instance.

# Iniciamos la instancia

SQL> startup
ORACLE instance started.

Total System Global Area 1577055360 bytes
Fixed Size		    9135232 bytes
Variable Size		  939524096 bytes
Database Buffers	  620756992 bytes
Redo Buffers		    7639040 bytes
Base de datos montada.
Base de datos abierta.

# Creamos el enlace

SQL>CREATE DATABASE LINK phoenixlink
CONNECT TO "juanan1" IDENTIFIED BY "juanan"
USING 'PHOENIX';

Enlace con la base de datos creado.
~~~

Vamos a hacer una consulta simple a la tabla `dept` desde la conexión que hemos creado (`phoenixlink`)
~~~
SQL> select *
from dept@phoenixlink;

+-------+---------------+--------------+
| deptno| dname         | loc          |
+-------+---------------+--------------+
| 10    | ACCOUNTING    | NEW YORK     |
| 20    | RESEARCH      | DALLAS       |
| 30    | SALES         | CHICAGO      |
| 40    | OPERATIONS    | BOSTON       |
+-------+---------------+--------------+
SQLRowCount returns 4
4 rows fetched
~~~
